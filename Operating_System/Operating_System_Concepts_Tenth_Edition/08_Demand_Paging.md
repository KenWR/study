[Background](#background)   
  - [Virtual memory](#virtual-memory)      

[Demand Paging](#demand-paging) 

---

@todo : 페이지 폴트 순서를 나열하고

  페이지 폴트 발생시에 각 예외부분
1. 명령어가 페이지 테이블을 참조함   
2. Valid-Invalid bit == I   
3. Trap 이 발생하고 이를 운영체제가 감지   
4. 페이지가 backing store에 있는 것을 확인   
5. 빈 프레임을 찾아서 swap   
6. 페이지 테이블을 갱신   
7. 명령어 재시작 

1번에서 문제가생기면 valid-invalid
5번에서 문제가 생기면 페이지 교체
4번에서 문제생기면....
등등 의 순서로 글 작성

## [Background]

### [Virtual Memory]
---
실제 물리 메모리로부터 사용자 논리 메모리를 분리한 것   

Logical Memory(논리 메모리) 라고도 불리운다   

이러한 논리 주소 공간은 파편화를 막기 위해 Page 단위로 공간을 나누었고   
물리 주소 공간 에서의 `Page` 는 `Frame` 이라고 불리운다   

이 가상주소의 특징은 다음과 같다   

프로그램의 일부만 이 가상 메모리에 올라와 있어도 실행이 가능하며 이로인해 논리 주소 공간이 물리 주소 공간보다 엄청 커질 수 있다
실제 메모리 공간보다 큰 프로그램들이 메모리 영역에서 여러개가 존재를 하게 되며 이는 프로그램이 동시성을 가지고 동작하게 된다   

![Alt text](images/virtualmemory.png)


각 프로세스마다 이러한 논리 주소 공간을 별도로 부여 받으며 특정 메모리 공간은 프로세스끼리 공유하기도 한다   

![Alt text](images/sharedmemory.png)   

## [Demand Paging]

### [Demand Paging]

Demand - 요구하다

디맨드 페이징은 시스템이 요구할 때마다 페이징을 해주는 방식이라고 보면 된다.   
이로 인해 필요한 페이지들만 메모리에 올라오게 되고, 여러 프로그램들이 동시성을 가지고 실행할 수 있게 된다.

그러나 우리가 필요한 페이지를 가져오고자 했을때, 필요한 메모리가 주 메모리에 있는지 아니면 보조 기억 장치에 있는지 어떻게 판별하는가?   
이는 하드웨어의 도움을 받아 각 페이지 테이블 엔트리마다 1비트를 연결하여 해당 페이지가 주 메모리에 있는지 없는지를 확인하는 '유효-무효 비트(Valid-Invalid bit)'를 이용한다.

![Alt text](images/valid_invalid.png)   

이렇게 해당 비트가 유효하면 페이지를 가져오고 무효하다면 `Page Fault`가 발생하게 된다

---

### [Page Fault Handling]

Page Fault 를 처리하는 순서는 다음과 같다      

1. 명령어가 페이지 테이블을 참조함   
2. Valid-Invalid bit == I   
3. Trap 이 발생하고 이를 운영체제가 감지   
4. 페이지가 backing store에 있는 것을 확인   
5. 빈 프레임을 찾아서 swap   
6. 페이지 테이블을 갱신   
7. 명령어 재시작   

---

이러한 디맨드 페이징에 대해 여러가지 양상들이 존재하는데 그중 대표적인 3가지가 있다   

1. Pure Page Fault   
  컴퓨터를 처음 켰을때 메모리에는 아무것도 없다   
  그 상황에서 프로그램을 실행시켰을때 처음부터 대부분의 작업까지는 무조건 Page Fault가 발생하게된다   
2. Locality of reference   
  명령어 add A, B, C 를 실행한다고 했을 때, A B C 각각 모두 서로 다른 페이지에 존재한다고 하면 3개의 Page Fault 가 발생할 수 있는데 이는 다행이도 지역성 덕분에 이러한 끔찍한 일은 거의 발생하지 않는다   
3. H/W 의 지원   
  바로 위에서의 유효-무효 비트와 같은 H/W 단계에서의 지원이 필요하며 swap을 위한 메모리공간 및 멈추었던 명령어의 재시작에 관련한 H/W의 지원이 필요하다    
  그 이유는 단순하게 성능측면에서 보았을때 S/W에서 처리하는 것 보다 H/W 에서 처리를 하였을 때 그 성능이 월등이 좋으면서 이와 같은 Demand Paging의 경우에는 구현자체에도 어려움이 있어 H/W의 지원을 받는것이 더 바람직하다   

page fault발생시 기본적으로 발생하는 작업이 있다

Instruction Restart:   
  context switching이 발생하는데, 과연 명령어 실행도중에 우리가 가지고 있던, 알고 있던 page 가 그대로 남아있을까? 라는 의문이 있다   
  그렇기에 이런 상황에서는 명령어를 처음부터 다시 시작해야할 것이다
  
  예를들어 ADD A, B, C 를 할 때에
  A, B 까지는 참조를 제대로 했는데 C 의 참조가 잘못되어 page fault 가 발생하여 page table이 갱신되는 도중에 기존에 있던 A, B의 페이지 위치가 그자리에 존재한다는 보장이 없다

Free Frame List:   
  운영체제가 빈 프레임을 연결리스트로 가지고 있어야

  페이지 폴트 발생시 보조기억장치에서 주기억장치로 페이지를 가져올때 빈 프레임 공간에 정보를 가져와야하기에 이를 관리해야한다

copy on write (cow):   
  대표적으로 fork() 를 예시로 들면되는데 fork를 하면 자식프로세스는 새로운 PCB 껍데기와 새로운 pid만 부여받고 대부분은 부모의 엔트리와 동일하다 그렇게 똑같은 주소공간을 공유해서 잘 쓰다가 write 를 해야하는 경우 이 둘의 공간은 달라야 하기 때문에 이를 분리해야 해서 새로 복사해서 그 엔트리 영역만 새로 복사하여 write를 하는것 


### [Page Replacement]

비어있는 프레임이 없는데 추가적인 페이지가 필요하다면?     
생각을 해보자, 6개의 프로세스와 40개의 프레임이 있는 상황에서 각 프로세스가 5개의 페이지로만 잘 돌아가다가 갑자기 10개의 페이지가 필요하게된다면 
전체적인 페이지가 부족해지는 현상이 발생한다

이러한 경우 메모리에 올라와 있는 페이지와  보조기억장치에 있는 페이지간의 교체가 필요하다

동작 방식은 다음과 같다

1. 교체체할  대대상  (victim) 을 선택한다
2. victim 을 page out
3. 필요한 페이지를 보조기억장치로부터 page in
4. 페이지 테이블을 갱신시킨다

여기서 dirty bit 가 나타나서 page out 시에 보조기억장치에 write 하는지 안하는지의 여부를 확인   

매번 보조기억장치에 write 를 하는것은 효율이 떨어진다 생각보다 보조기억장치에 대한 I/O는 비용이 비싸다

프레임 개수가 많을 수록 페이지폴트는 적어진다

페이지 교체를 할 때, victim은 어떻게 정해지는가?

7 0 1 2 0 3 0 4 2 3 0 3 0 3 2 1 2 0 1 7 0 1

라는 참조 문자열이 있다   
각 숫자의 의미는 참조한 프레임의 인덱스를 의미한다   

1. FIFO
2. Optimize
3. LRU
4. Second-Chance

belady's Anomaly
  할당된 프레임의 개수가 일정이상 높아지면 페이지폴트 비율이 높아짐

왜>?

fifo가 그만큼 구려서


LRU's stack algorithm
  N개의 프레임으로 구성된 메모리에 로드된 페이지들이 항상 N+1개의 프레임으로 구성된 메모리에 로드된 페이지들의 부분집합이 되는 알고리즘   
  Belady's anomaly가 절대 발생하지 않음   

LRU approximations

참조비트 더 추가

or 

Clock algorithm:   
  Clock hand 가 가리키는 패이지의 참조비트가 1이면 0으로 바꾸고 다음페이지를 계속 가리키면서 반복하다가 참조비트가 0인 페이지를 만나면 해당 페이지를 victim으로 선택하는 알고리즘

만약 모든 참조비트가 다 1이면?   
주메모리가 너무 작아서 page fault가 많다는 뜻   

그래서 os에서 clock hand가 얼마나 빨리 돌고있는가를 성능척도에 사용하기도함   

결국 모든 참조비트가 다 1이면 FIFO로 변신해버림

Enhanced clock algorithm

dirty bit를 추가한것
보조기억장치의 I/O를 줄이기위해 그래도 가장 우선순위애서 I/O를 안해도 되는 놈을 고르는 것   

만약 참조비트를 제공하지 않는 아키텍쳐면?

FIFO 사용 혹은 Frame buffering 사용

Frame buffering:   
  빈 프레임 pool을 계속 유지하여 frame이 차는것을 방지   
  그리고 빈 프레임 pool의 내용을 초기화 하지않고 만약 빈 프레임 목록에 있는 프레임중 하나가 재참조되면 바로 그대로 꺼내서 쓸 수 있게 해줌   
  FIFO와 같이 사용   

swap device가 유휴한 상태면 dirty bit에 따라서 write를 해주고 clean bit로 재설정가능   
이러한 방식으로 swap I/O를 최소화(감추기) 할 수 잇음   



LRU 

프레임 할당방법
equal vs proportional

그냥 전부 프레임 10개씩   
vs   
큰 프로세스는 더 많이  

page replacement 범위
global
process
user

### [Thrashing]

CPU scheduler 와 Memory Management 사이에서 발생하는 괴리   

CPU utilization이 낮으면 추가적인 프로세스들을 투입하는 역할을 CPU 스케줄러가 하는데 문제는 메모리에 상주하는 프로세스들이 너무 많아짐에 따라 페이지 폴트가 많이 발생하게되고 그로인한 문맥교환이나 보조기억장치 I/O가 많이 발생함으로서 실행중인 프로세스들이 대부분 대기상태로 들어가면서 CPU사용량이 줄어들게되는데 이를 본 CPU스케줄러가 추가적인 프로세스들을 투입하게되어 process가 너무 과다해지고 처음부터 다시 똑같은 악순환이 발생하게 되는것   

즉 메모리가 overcommitted 된것   

working set을 이용하여 해결

---

### [Working Set]

어느 시점에 특정 프로세스가 액세스하는 페이지들의 집합

해당 프로세스의 지역성이라고 보면됨   

이러한 지역성이 바뀌는것이 Working set이 변하는 것

그런데 이 워킹셋의 범위를 지정하는것이 굉장히 어려움

prepaging:   
  실제 페이지 요청이 있기전에 액세스될 것으로 보이는 페이지를 미리 예상하여 메모리에 로드하는 것   

프리페이징 할때 워킹셋을 제대로 알면 페이지 폴트를 적게 불러올 수 있음   

그래서 워킹셋은 어떻게 정확하게 알 수 있을까?

그렇기에 과거에 사용된 프로세스의 페이지들을 가지고 예측하는 것   

그래서 실제로 점심시간에 밥먹고오면 컴퓨터가 느려지는것을 느낄수 있었다고함   

피터데닝이라는 사람이 working set parameter를 고안함:   
  t 시간동안 프로세스가 접근한 페이지들을 working set 이라고 정의

그런데 t 시간동안 너무 많거나 적은 페이지가 들어오게된다면?   

다르게 생각해보자 기준을 다르게 잡는다면 워킹셋을 잘 만들 수 잇을것이다.   

기준은 간단하다 모든 프로세스들이 잘 돌아가고 있다면 그로인에 스레싱이 발생하지 않고 잘 돌아가고 있다는것은 모든 프로세스들이 절절한 워킹셋을 들고 동작하고 있다는 뜻이다

그렇다면 운영체제가 현재 돌아가고 있는 프로세스들이 잘 돌고 있는것을 알 수 있을까?

그것은 간단하게도 페이지폴트가 얼마나 발생하고 있는지를 확인하면 된다   

이에는 local placement가 필요하다

즉 페이지 폴트 발생횟수에 따라 운영체제가 메모리를 할당하는 기준은   
  스레시홀드보다 많이 발생시 해당 프로세스에게 더 많은 메모리 할당   
  스레시홀드보다 적게 발생시 해당 프로세스에게 할당된 메모리를 회수

그렇게 만들어진 워킹셋을 레지던트 셋이라고 한다




---





