[Background](#background)   
  - [Virtual memory](#virtual-memory)      

[Demand Paging](#demand-paging) 

---

## [Background]

### [Virtual Memory]
---
실제 물리 메모리로부터 사용자 논리 메모리를 분리한 것   

Logical Memory(논리 메모리) 라고도 불리운다   

이러한 논리 주소 공간은 파편화를 막기 위해 Page 단위로 공간을 나누었고   
물리 주소 공간 에서의 `Page` 는 `Frame` 이라고 불리운다   

이 가상주소의 특징은 다음과 같다   

프로그램의 일부만 이 가상 메모리에 올라와 있어도 실행이 가능하며 이로인해 논리 주소 공간이 물리 주소 공간보다 엄청 커질 수 있다
실제 메모리 공간보다 큰 프로그램들이 메모리 영역에서 여러개가 존재를 하게 되며 이는 프로그램이 동시성을 가지고 동작하게 된다   

![Alt text](images/virtualmemory.png)


각 프로세스마다 이러한 논리 주소 공간을 별도로 부여 받으며 특정 메모리 공간은 프로세스끼리 공유하기도 한다   

![Alt text](images/sharedmemory.png)   

## [Demand Paging]

### [Demand Paging]

Demand - 요구하다

디맨드 페이징은 시스템이 요구할 때마다 페이징을 해주는 방식이라고 보면 된다.   
이로 인해 필요한 페이지들만 메모리에 올라오게 되고, 여러 프로그램들이 동시성을 가지고 실행할 수 있게 된다.

그러나 우리가 필요한 페이지를 가져오고자 했을때, 필요한 메모리가 주 메모리에 있는지 아니면 보조 기억 장치에 있는지 어떻게 판별하는가?   
이는 하드웨어의 도움을 받아 각 페이지 테이블 엔트리마다 1비트를 연결하여 해당 페이지가 주 메모리에 있는지 없는지를 확인하는 '유효-무효 비트(Valid-Invalid bit)'를 이용한다.

![Alt text](images/valid_invalid.png)   

이렇게 해당 비트가 유효하면 페이지를 가져오고 무효하다면 `Page Fault`가 발생하게 된다

---

### [Page Fault Handling]

Page Fault 를 처리하는 순서는 다음과 같다      

1. 명령어가 페이지 테이블을 참조함   
2. Valid-Invalid bit == I   
3. Trap 이 발생하고 이를 운영체제가 감지   
4. 페이지가 backing store에 있는 것을 확인   
5. 빈 프레임을 찾아서 swap   
6. 페이지 테이블을 갱신   
7. 명령어 재시작   

---

이러한 디맨드 페이징에 대해 여러가지 양상들이 존재하는데 그중 대표적인 3가지가 있다   

1. Pure Page Fault   
  컴퓨터를 처음 켰을때 메모리에는 아무것도 없다   
  그 상황에서 프로그램을 실행시켰을때 처음부터 대부분의 작업까지는 무조건 Page Fault가 발생하게된다   
2. Locality of reference   
  명령어 add A, B, C 를 실행한다고 했을 때, A B C 각각 모두 서로 다른 페이지에 존재한다고 하면 3개의 Page Fault 가 발생할 수 있는데 이는 다행이도 지역성 덕분에 이러한 끔찍한 일은 거의 발생하지 않는다   
3. H/W 의 지원   
  바로 위에서의 유효-무효 비트와 같은 H/W 단계에서의 지원이 필요하며 swap을 위한 메모리공간 및 멈추었던 명령어의 재시작에 관련한 H/W의 지원이 필요하다    
  그 이유는 단순하게 성능측면에서 보았을때 S/W에서 처리하는 것 보다 H/W 에서 처리를 하였을 때 그 성능이 월등이 좋으면서 이와 같은 Demand Paging의 경우에는 구현자체에도 어려움이 있어 H/W의 지원을 받는것이 더 바람직하다   

### [Thrashing]



---

### [Working Set]

---





